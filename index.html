<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>機甲番12問產生器 (含裁切功能)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Import Map for React & Lucide -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>
    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #171717; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #404040; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #525252; }
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fade-in 0.2s ease-out; }
        body { background-color: #171717; }
        /* Crop Area Styles */
        .crop-container { cursor: move; touch-action: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Download, Trash2, RotateCcw, Upload, Link as LinkIcon, X, AlertCircle, Camera, Loader2, Share2, Check, Save, Move, ZoomIn, Edit3 } from 'lucide-react';

        const DEFAULT_GRID_LABELS = [
            "入坑機", "第一台愛機", "最佳機設", "最強",
            "真男人要用...", "最喜歡的量產機", "最喜歡的主角機", "最喜歡的反派機",
            "最意難平", "最想開", "最帥氣", "最難忘"
        ];

        // --- Cropper Component ---
        const ImageCropper = ({ imageSrc, onConfirm, onCancel }) => {
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const imgRef = useRef(null);
            const containerRef = useRef(null);

            // Calculate min scale to cover the area
            useEffect(() => {
                if (imgRef.current && containerRef.current) {
                    const img = imgRef.current;
                    const container = containerRef.current;
                    // Aspect ratio is 3:4 (300:400)
                    const aspect = 3/4; 
                    // Initial fitting logic could go here if needed
                }
            }, [imageSrc]);

            const handleMouseDown = (e) => {
                setIsDragging(true);
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setDragStart({ x: clientX - position.x, y: clientY - position.y });
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setPosition({ x: clientX - dragStart.x, y: clientY - dragStart.y });
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            const handleCrop = () => {
                const canvas = document.createElement('canvas');
                // Output size: 600x800 (Double the display size for quality)
                const outWidth = 600;
                const outHeight = 800;
                canvas.width = outWidth;
                canvas.height = outHeight;
                const ctx = canvas.getContext('2d');

                const img = imgRef.current;
                
                // Calculations to map the visible CSS transform to Canvas drawImage
                // The container is fixed size (e.g. 300x400 in UI), but we want high res output.
                // We need to map the "visual" pixels to "image" pixels.
                
                // Let's rely on drawing the image with the same offsets scaled up
                // Container visual size (CSS pixels)
                const contW = 300; 
                const contH = 400;

                // Create a temporary canvas to apply transformations
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, outWidth, outHeight);
                
                // Scale factor between visual container and output canvas
                const outputScale = outWidth / contW; // 2

                ctx.save();
                // Move to center to scale from center? No, our transform origin is usually center or top-left.
                // In CSS transform logic above: translate(x, y) scale(s)
                // We are emulating the visual appearance onto the canvas.
                
                // 1. Move to the translated position (scaled up for output)
                ctx.translate(position.x * outputScale, position.y * outputScale);
                
                // 2. Scale from center of the image visually? 
                // The CSS transform-origin defaults to 50% 50% of the element (the image).
                // To match CSS:
                // Move to center of image -> Scale -> Move back
                const imgCenterX = (img.width * outputScale) / 2;
                const imgCenterY = (img.height * outputScale) / 2;

                // However, our simplified CSS logic applies transform to the <img> element directly.
                // Let's try a simpler approach: Draw the image at (x,y) with width*scale, height*scale.
                // But we need to account that the pivot point for scaling in our simple UI 
                // might look different if we don't align origins.
                
                // Let's just draw it:
                // Visible Width = NaturalWidth * Scale
                // Visible X = position.x
                
                // To keep it centered initially:
                // We need to render the image centered in the canvas, plus the user offset.
                
                // Center of Canvas
                const cx = outWidth / 2;
                const cy = outHeight / 2;

                // Draw Image properties
                const drawW = img.naturalWidth * scale * (outWidth / img.naturalWidth * (img.naturalWidth/contW)); // Approximate mapping?
                // Actually easier:
                // The visual image width is img.width (displayed) * scale.
                // img.width in CSS is usually "auto" or constrained.
                
                // Let's compute exact pixel mapping.
                // CSS displayed width (before scale)
                const displayW = img.width; 
                const displayH = img.height;

                ctx.translate(cx, cy);
                ctx.translate(position.x * outputScale, position.y * outputScale);
                ctx.scale(scale, scale);
                
                // Draw image centered at origin
                // We need to draw the source image such that it fits the container logic
                // If the image was "object-fit: cover" initially, we need to replicate that base scale?
                // Let's assume the user starts from 1:1 pixel mapping relative to container? No.
                
                // SIMPLIFIED LOGIC:
                // Just draw the image. 
                // position.x is relative to the center of container? 
                // Let's adjust the UI to be easier to map.
                // In UI: Image is centered in container. User moves it (translate) and scales it (scale).
                
                ctx.drawImage(
                    img, 
                    -img.naturalWidth / 2 * (outWidth/displayW), // This mapping is tricky without knowing exact display render
                    -img.naturalHeight / 2 * (outWidth/displayW) 
                );
                
                // RE-ATTEMPTING ROBUST CROP LOGIC:
                // Instead of complex math, let's just draw what the user sees relative to the container.
                // Container is 300x400.
                // Image is displayed with style { transform: translate(x,y) scale(s) }
                // Image is naturally centered via flexbox in UI.
                
                const ratio = img.naturalWidth / img.naturalHeight;
                let baseW, baseH;
                
                // "Contain" logic as base size to ensure it fits? Or just use natural size?
                // Let's use the logic that fits the image into the view initially.
                if (ratio > 3/4) {
                    // Wider than container
                    baseH = contH;
                    baseW = contH * ratio;
                } else {
                    // Taller than container
                    baseW = contW;
                    baseH = contW / ratio;
                }
                
                // Now we have the size of the image "at scale 1" in the UI (before user zoom)
                // Draw onto output canvas (size 600x800, so 2x factor)
                ctx.restore(); // reset
                ctx.clearRect(0,0,outWidth,outHeight);
                ctx.save();
                
                // Output center
                ctx.translate(outWidth/2, outHeight/2);
                // User pan (scaled x2)
                ctx.translate(position.x * 2, position.y * 2);
                // User zoom
                ctx.scale(scale, scale);
                
                // Draw image centered
                ctx.drawImage(
                    img, 
                    -baseW, // baseW is roughly half size visually (300px), so * 2 for output? No baseW is CSS px.
                    -baseH, 
                    baseW * 2, 
                    baseH * 2
                );
                
                ctx.restore();
                
                onConfirm(canvas.toDataURL('image/png'));
            };

            return (
                <div className="flex flex-col h-full">
                     <div className="flex-1 bg-black/50 flex items-center justify-center overflow-hidden relative select-none">
                        {/* Crop Frame (3:4) */}
                        <div 
                            ref={containerRef}
                            className="relative overflow-hidden border-2 border-white shadow-[0_0_0_9999px_rgba(0,0,0,0.7)]"
                            style={{ width: '300px', height: '400px' }}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                            onTouchStart={handleMouseDown}
                            onTouchMove={handleMouseMove}
                            onTouchEnd={handleMouseUp}
                        >
                            <img 
                                ref={imgRef}
                                src={imageSrc}
                                alt="Crop target"
                                className="absolute top-1/2 left-1/2 max-w-none origin-center pointer-events-none"
                                style={{ 
                                    transform: `translate(-50%, -50%) translate(${position.x}px, ${position.y}px) scale(${scale})`,
                                    // Initial sizing logic handled by calculating baseW/baseH above implicitly by using max-height/width constraints?
                                    // To match the canvas logic, we need explicit sizing.
                                    // Let's force "Contain" logic via JS or specific CSS
                                    height: (imgRef.current?.naturalWidth / imgRef.current?.naturalHeight > 3/4) ? '400px' : 'auto',
                                    width: (imgRef.current?.naturalWidth / imgRef.current?.naturalHeight > 3/4) ? 'auto' : '300px',
                                }}
                                onLoad={(e) => {
                                    // Reset on load
                                    setScale(1); 
                                    setPosition({x:0, y:0});
                                }}
                            />
                            {/* Grid overlay */}
                            <div className="absolute inset-0 grid grid-cols-3 grid-rows-3 pointer-events-none opacity-30">
                                <div className="border-r border-white/50"></div>
                                <div className="border-r border-white/50"></div>
                                <div className=""></div>
                                <div className="border-r border-t border-white/50"></div>
                                <div className="border-r border-t border-white/50"></div>
                                <div className="border-t border-white/50"></div>
                                <div className="border-r border-t border-white/50"></div>
                                <div className="border-r border-t border-white/50"></div>
                                <div className="border-t border-white/50"></div>
                            </div>
                        </div>
                        
                        {/* Hint */}
                        <div className="absolute bottom-4 left-0 right-0 text-center pointer-events-none">
                            <span className="bg-black/60 text-white text-xs px-3 py-1 rounded-full flex items-center justify-center gap-1 w-fit mx-auto">
                                <Move size={12}/> 拖曳移動圖片
                            </span>
                        </div>
                     </div>

                     {/* Controls */}
                     <div className="p-4 bg-neutral-800 border-t border-neutral-700 space-y-4">
                        <div className="flex items-center gap-3">
                            <ZoomIn size={20} className="text-neutral-400"/>
                            <input 
                                type="range" 
                                min="0.5" 
                                max="3" 
                                step="0.05" 
                                value={scale}
                                onChange={(e) => setScale(parseFloat(e.target.value))}
                                className="w-full h-2 bg-neutral-600 rounded-lg appearance-none cursor-pointer accent-blue-500"
                            />
                            <span className="text-white w-10 text-right">{(scale * 100).toFixed(0)}%</span>
                        </div>
                        <div className="flex gap-3">
                            <button onClick={onCancel} className="flex-1 py-3 bg-neutral-700 text-white rounded-lg font-bold">取消</button>
                            <button onClick={handleCrop} className="flex-1 py-3 bg-blue-600 text-white rounded-lg font-bold">確認使用</button>
                        </div>
                     </div>
                </div>
            );
        };


        const ImageModal = ({ isOpen, onClose, title, onUrlSelect }) => {
            const [imageUrl, setImageUrl] = useState('');
            const [activeTab, setActiveTab] = useState('upload'); 
            const fileInputRef = useRef(null);
            
            // Cropper State
            const [tempImage, setTempImage] = useState(null); // The raw uploaded image
            
            useEffect(() => {
                if (isOpen) {
                    setImageUrl('');
                    setTempImage(null);
                    setActiveTab('upload');
                }
            }, [isOpen]);

            if (!isOpen) return null;

            // If we have a temp image, show cropper
            if (tempImage) {
                return (
                    <div className="fixed inset-0 z-[100] bg-black/90 backdrop-blur-sm animate-fade-in flex flex-col">
                        <div className="flex justify-between items-center p-4 border-b border-neutral-800 bg-neutral-900">
                             <h3 className="text-white font-bold">調整圖片: {title}</h3>
                             <button onClick={() => setTempImage(null)}><X className="text-white"/></button>
                        </div>
                        <div className="flex-1 overflow-hidden">
                            <ImageCropper 
                                imageSrc={tempImage}
                                onConfirm={(croppedDataUrl) => {
                                    onUrlSelect(croppedDataUrl);
                                    setTempImage(null);
                                }}
                                onCancel={() => setTempImage(null)}
                            />
                        </div>
                    </div>
                );
            }

            const handleUrlSubmit = (e) => {
                e.preventDefault();
                if (imageUrl) {
                    // For URL, we can't easily crop due to CORS taint on canvas often.
                    // We just use it directly or try to load it into cropper if CORS permits.
                    // Let's try to load into cropper.
                    setTempImage(imageUrl);
                }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setTempImage(e.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            };

            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-fade-in">
                    <div className="bg-neutral-900 w-full max-w-md rounded-2xl border border-neutral-700 shadow-2xl overflow-hidden flex flex-col max-h-[90vh]">
                        <div className="flex justify-between items-center p-4 border-b border-neutral-800 bg-neutral-800/50">
                            <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                <span className="text-blue-400">#{title}</span>
                            </h3>
                            <button onClick={onClose} className="p-2 hover:bg-neutral-700 rounded-full transition-colors text-neutral-400 hover:text-white">
                                <X size={20} />
                            </button>
                        </div>
                        <div className="flex border-b border-neutral-800 shrink-0">
                            <button 
                                onClick={() => setActiveTab('upload')}
                                className={`flex-1 py-4 text-sm font-medium transition-colors flex items-center justify-center gap-2 ${activeTab === 'upload' ? 'text-blue-400 border-b-2 border-blue-400 bg-blue-500/10' : 'text-neutral-400 hover:text-neutral-200'}`}
                            >
                                <Upload size={18} /> 本機上傳
                            </button>
                            <button 
                                onClick={() => setActiveTab('url')}
                                className={`flex-1 py-4 text-sm font-medium transition-colors flex items-center justify-center gap-2 ${activeTab === 'url' ? 'text-blue-400 border-b-2 border-blue-400 bg-blue-500/10' : 'text-neutral-400 hover:text-neutral-200'}`}
                            >
                                <LinkIcon size={18} /> 圖片網址
                            </button>
                        </div>
                        <div className="p-6 bg-neutral-900 min-h-[300px]">
                            {activeTab === 'upload' && (
                                <div className="flex flex-col items-center justify-center space-y-6 py-4 h-full">
                                    <div 
                                        onClick={() => fileInputRef.current?.click()}
                                        className="w-full border-2 border-dashed border-neutral-600 hover:border-blue-400 hover:bg-neutral-800/50 rounded-xl p-10 cursor-pointer transition-all group text-center"
                                    >
                                        <div className="w-16 h-16 bg-neutral-800 rounded-full flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform">
                                            <Upload size={32} className="text-neutral-400 group-hover:text-blue-400" />
                                        </div>
                                        <h4 className="text-white font-bold text-lg mb-2">
                                            選擇「<span className="text-blue-400">{title}</span>」的圖片
                                        </h4>
                                        <p className="text-neutral-500 text-sm">選擇後可裁切位置</p>
                                    </div>
                                    <input 
                                        type="file" 
                                        ref={fileInputRef}
                                        onChange={handleFileUpload}
                                        accept="image/*"
                                        className="hidden"
                                    />
                                </div>
                            )}
                            {activeTab === 'url' && (
                                <div className="space-y-6 pt-2">
                                    <form onSubmit={handleUrlSubmit} className="space-y-4">
                                        <div>
                                            <label className="block text-neutral-400 text-sm mb-2">圖片網址</label>
                                            <div className="relative">
                                                <input 
                                                    type="url" 
                                                    value={imageUrl}
                                                    onChange={(e) => setImageUrl(e.target.value)}
                                                    placeholder="https://..."
                                                    className="w-full bg-neutral-800 border border-neutral-700 rounded-lg pl-10 pr-4 py-3 text-white focus:outline-none focus:border-blue-500 placeholder-neutral-600"
                                                />
                                                <LinkIcon className="absolute left-3 top-3.5 text-neutral-500" size={18} />
                                            </div>
                                        </div>
                                        <button 
                                            type="submit"
                                            disabled={!imageUrl}
                                            className="w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 rounded-lg transition-colors"
                                        >
                                            進入裁切
                                        </button>
                                    </form>
                                    <div className="bg-yellow-900/20 border border-yellow-900/50 rounded-lg p-4 text-sm text-yellow-200/80 flex gap-2">
                                        <AlertCircle size={16} className="shrink-0 mt-0.5" />
                                        <span>注意：跨域圖片可能無法裁切，系統會盡力嘗試載入。</span>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const ResultModal = ({ isOpen, onClose, resultImage }) => {
            if (!isOpen || !resultImage) return null;

            return (
                <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/90 backdrop-blur-sm p-4 animate-fade-in">
                    <div className="relative w-full max-w-4xl flex flex-col items-center h-full md:h-auto">
                        
                        <button 
                            onClick={onClose}
                            className="absolute top-0 right-0 md:-top-10 md:-right-10 p-2 text-white/70 hover:text-white transition-colors"
                        >
                            <X size={32} />
                        </button>

                        <h2 className="text-2xl font-bold text-white mb-4 flex items-center gap-2">
                            <Check className="text-green-500" /> 圖片已生成
                        </h2>

                        <div className="bg-neutral-800 p-2 rounded-lg shadow-2xl border border-neutral-700 overflow-auto max-h-[65vh] w-full flex justify-center">
                            <img 
                                src={resultImage} 
                                alt="Generated Result" 
                                className="max-w-full h-auto object-contain"
                            />
                        </div>

                        <div className="flex flex-col items-center gap-5 mt-6 w-full max-w-md">
                            <div className="text-center space-y-2 bg-blue-900/10 border border-blue-500/30 p-4 rounded-xl w-full">
                                <div className="flex items-center justify-center gap-2 text-blue-300 font-bold text-lg mb-1">
                                    <Save size={20} />
                                    <span>如何儲存圖片？</span>
                                </div>
                                <div className="text-neutral-300 text-sm leading-relaxed">
                                    <p><span className="text-blue-400 font-bold">電腦：</span>滑鼠右鍵 ➝ 另存圖片</p>
                                    <p><span className="text-blue-400 font-bold">手機：</span>長按圖片 ➝ 加入照片 / 下載</p>
                                </div>
                            </div>
                            
                            <button 
                                onClick={onClose}
                                className="w-full bg-neutral-700 hover:bg-neutral-600 text-white px-8 py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-all shadow-lg"
                            >
                                <RotateCcw size={18} />
                                關閉視窗 / 繼續編輯
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const MechaGridMaker = () => {
            const [images, setImages] = useState(Array(12).fill(null));
            const [gridLabels, setGridLabels] = useState(DEFAULT_GRID_LABELS);
            const [mainTitle, setMainTitle] = useState("機甲番12問");
            const [isEditMode, setIsEditMode] = useState(false); // Toggle for editing labels

            const [isGenerating, setIsGenerating] = useState(false);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [activeCell, setActiveCell] = useState(null);
            
            const [resultImage, setResultImage] = useState(null);
            const [isResultOpen, setIsResultOpen] = useState(false);

            const openModal = (index) => {
                setActiveCell(index);
                setIsModalOpen(true);
            };

            const closeModal = () => {
                setIsModalOpen(false);
                setActiveCell(null);
            };

            const handleImageSelect = (dataUrl) => {
                if (activeCell !== null) {
                    const newImages = [...images];
                    newImages[activeCell] = dataUrl;
                    setImages(newImages);
                    closeModal();
                }
            };

            const clearImage = (index, e) => {
                e.stopPropagation();
                const newImages = [...images];
                newImages[index] = null;
                setImages(newImages);
            };

            const resetAll = () => {
                if (window.confirm('確定要清空所有圖片嗎？')) {
                    setImages(Array(12).fill(null));
                    setResultImage(null);
                }
            };

            const handleLabelChange = (index, value) => {
                const newLabels = [...gridLabels];
                newLabels[index] = value;
                setGridLabels(newLabels);
            };

            const generateImage = async () => {
                setIsGenerating(true);
                await new Promise(r => setTimeout(r, 100));

                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const cellWidth = 300;
                    const cellHeight = 400;
                    const headerHeight = 160;
                    const cols = 4;
                    const rows = 3;
                    const borderThickness = 10;
                    const totalWidth = (cellWidth * cols) + (borderThickness * (cols + 1));
                    const totalHeight = headerHeight + (cellHeight * rows) + (borderThickness * (rows + 1));

                    canvas.width = totalWidth;
                    canvas.height = totalHeight;

                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw Main Title
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 100px "Noto Sans TC", "Microsoft JhengHei", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(mainTitle, totalWidth / 2, headerHeight / 2 + 10);

                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, headerHeight, totalWidth, totalHeight - headerHeight);

                    const loadImage = (src) => {
                        return new Promise((resolve, reject) => {
                            const img = new Image();
                            if (!src.startsWith('data:')) {
                                img.crossOrigin = "anonymous";
                            }
                            img.onload = () => resolve(img);
                            img.onerror = () => reject(new Error("Image Load Failed"));
                            img.src = src;
                        });
                    };

                    let errorCount = 0;
                    for (let i = 0; i < 12; i++) {
                        const col = i % 4;
                        const row = Math.floor(i / 4);
                        const x = borderThickness + (col * (cellWidth + borderThickness));
                        const y = headerHeight + borderThickness + (row * (cellHeight + borderThickness));

                        ctx.fillStyle = '#f3f4f6';
                        ctx.fillRect(x, y, cellWidth, cellHeight);

                        if (images[i]) {
                            try {
                                const img = await loadImage(images[i]);
                                // Image is already cropped to aspect ratio by the modal, so we just fill
                                ctx.drawImage(img, x, y, cellWidth, cellHeight);
                            } catch (e) {
                                console.error(`Failed to load image at index ${i}`, e);
                                errorCount++;
                                ctx.fillStyle = '#fee2e2';
                                ctx.fillRect(x, y, cellWidth, cellHeight);
                                ctx.fillStyle = '#ef4444';
                                ctx.font = 'bold 20px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('無法讀取', x + cellWidth/2, y + cellHeight/2);
                            }
                        }

                        ctx.save();
                        ctx.font = 'bold 36px "Noto Sans TC", "Microsoft JhengHei", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        const textX = x + (cellWidth / 2);
                        const textY = y + cellHeight - 15;
                        
                        ctx.lineWidth = 6;
                        ctx.strokeStyle = 'black';
                        ctx.lineJoin = 'round';
                        ctx.strokeText(gridLabels[i], textX, textY);
                        
                        ctx.fillStyle = 'white';
                        ctx.fillText(gridLabels[i], textX, textY);
                        ctx.restore();
                    }

                    if (errorCount > 0) {
                        alert(`注意：有 ${errorCount} 張圖片因為格式問題無法繪製。`);
                    }

                    const dataUrl = canvas.toDataURL('image/png');
                    setResultImage(dataUrl);
                    setIsResultOpen(true);

                } catch (err) {
                    console.error(err);
                    alert("生成失敗，請重試。");
                } finally {
                    setIsGenerating(false);
                }
            };

            return (
                <div className="min-h-screen bg-neutral-900 text-white p-4 pb-20 font-sans">
                    <div className="max-w-5xl mx-auto">
                        <div className="text-center mb-6 space-y-4">
                            {/* Editable Title */}
                            <div className="relative group inline-block">
                                <input 
                                    type="text"
                                    value={mainTitle}
                                    onChange={(e) => setMainTitle(e.target.value)}
                                    className="text-4xl md:text-6xl font-black tracking-tight text-white bg-transparent text-center border-b-2 border-transparent hover:border-blue-500 focus:border-blue-500 focus:outline-none transition-all w-full md:w-auto"
                                    placeholder="輸入標題"
                                />
                                <Edit3 size={20} className="absolute -right-6 top-1/2 -translate-y-1/2 text-neutral-500 opacity-0 group-hover:opacity-100 transition-opacity" />
                            </div>

                            <div className="flex justify-center items-center gap-2 mb-2">
                                <p className="text-neutral-400 text-sm md:text-base">
                                    點擊格子填入圖片 (可裁切縮放)
                                </p>
                                <button 
                                    onClick={() => setIsEditMode(!isEditMode)}
                                    className={`text-xs px-2 py-1 rounded border ${isEditMode ? 'bg-blue-600 border-blue-600 text-white' : 'border-neutral-600 text-neutral-400 hover:text-white'}`}
                                >
                                    {isEditMode ? '完成編輯文字' : '修改格子文字'}
                                </button>
                            </div>
                            
                            <div className="flex justify-center gap-4 sticky top-4 z-40">
                                <button 
                                    onClick={generateImage}
                                    disabled={isGenerating}
                                    className={`bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-full font-bold shadow-lg flex items-center gap-2 transition-all transform hover:scale-105 active:scale-95 disabled:opacity-70 disabled:cursor-wait`}
                                >
                                    {isGenerating ? (
                                        <>
                                            <Loader2 className="animate-spin" size={20} />
                                            處理中...
                                        </>
                                    ) : (
                                        <>
                                            <Share2 size={20} />
                                            生成圖片
                                        </>
                                    )}
                                </button>
                                <button 
                                    onClick={resetAll}
                                    disabled={isGenerating}
                                    className="bg-neutral-700 hover:bg-neutral-600 text-white px-4 py-3 rounded-full font-bold shadow-lg flex items-center gap-2 transition-all"
                                >
                                    <RotateCcw size={20} />
                                    重置
                                </button>
                            </div>
                        </div>

                        <div 
                            className="grid grid-cols-2 md:grid-cols-4 gap-2 md:gap-3 bg-black p-2 md:p-3 rounded-lg shadow-2xl border-4 border-black mx-auto"
                            style={{ maxWidth: '1000px' }}
                        >
                            {gridLabels.map((label, index) => (
                                <div 
                                    key={index}
                                    onClick={() => !isEditMode && openModal(index)}
                                    className="relative aspect-[3/4] bg-neutral-800 cursor-pointer group overflow-hidden border-2 border-transparent hover:border-blue-400 transition-colors"
                                >
                                    {images[index] ? (
                                        <>
                                            <img 
                                                src={images[index]} 
                                                alt={label} 
                                                className="w-full h-full object-cover"
                                                crossOrigin={images[index].startsWith('data:') ? undefined : "anonymous"}
                                            />
                                            {!isEditMode && (
                                                <button 
                                                    onClick={(e) => clearImage(index, e)}
                                                    className="absolute top-2 right-2 bg-black/60 hover:bg-red-600 text-white p-1.5 rounded-full opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity z-10"
                                                    title="移除圖片"
                                                >
                                                    <Trash2 size={16} />
                                                </button>
                                            )}
                                        </>
                                    ) : (
                                        <div className="absolute inset-0 flex flex-col items-center justify-center text-neutral-500 group-hover:text-neutral-300 transition-colors">
                                            <div className="bg-neutral-700/50 p-4 rounded-full mb-2">
                                                <Camera size={32} className="md:w-10 md:h-10 opacity-70" />
                                            </div>
                                            <span className="text-xs md:text-sm font-medium">上傳圖片</span>
                                        </div>
                                    )}
                                    
                                    {/* Text Overlay Area */}
                                    <div className="absolute bottom-0 left-0 right-0 p-3 flex justify-center items-end pointer-events-none bg-gradient-to-t from-black/60 to-transparent pt-10">
                                        {isEditMode ? (
                                            <input 
                                                type="text"
                                                value={label}
                                                onChange={(e) => handleLabelChange(index, e.target.value)}
                                                onClick={(e) => e.stopPropagation()}
                                                className="pointer-events-auto bg-black/50 text-white border-b border-white text-center w-full focus:outline-none"
                                            />
                                        ) : (
                                            <span 
                                                className="text-lg md:text-2xl font-bold text-white tracking-wide text-center leading-tight"
                                                style={{ 
                                                    textShadow: '2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000'
                                                }}
                                            >
                                                {label}
                                            </span>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div className="h-10"></div>
                        
                        <ImageModal 
                            isOpen={isModalOpen}
                            onClose={closeModal}
                            title={activeCell !== null ? gridLabels[activeCell] : ''}
                            onUrlSelect={handleImageSelect}
                        />

                        <ResultModal 
                            isOpen={isResultOpen}
                            onClose={() => setIsResultOpen(false)}
                            resultImage={resultImage}
                        />
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<MechaGridMaker />);
    </script>
</body>
</html>
